#pragma once
class boolsProxy
{
    long long* mem;
    const int& index;
    public:
    boolsProxy(long long* mem,const int& index)
        :mem(mem), index(index) {}
    operator bool()
    {
        return getData();
    }
    bool operator++ ()
    {
        pushData(true);
        return *this;
    }
    bool operator-- ()
    {
        pushData(false);
        return *this;
    }
    bool operator++ (int)
    {
        bool temp = *this;
        pushData(true);
        return temp;
    }
    bool operator-- (int)
    {
        bool temp = *this;
        pushData(false);
        return temp;
    }
    bool flip()
    {
        pushData(!(*this));
        return *this;
    }
    const boolsProxy& operator= (const bool& value)
    {
        pushData(value);
        return *this;
    }
    const bool getData () const
    {
        return (*mem >> index) & 1;
    }
    void pushData(const bool& data)
    {
        *mem ^= (-data ^ *mem) & (1 << index);
    }
};
class sbool
{
    char mem = 0b0000'0000;
    public:
    sbool(const char& data)
        : mem(data) {}
    sbool() {}
    boolsProxy operator[] (const int& index)
    {
        return boolsProxy((long long*)&mem, index);
    }
    
};
class lbool
{
    short mem = 0b0000'0000'000'0000;
    public:
    lbool(const short& data)
        : mem(data) {}
    lbool() {}
    boolsProxy operator[] (const int& index)
    {
        return boolsProxy((long long*)&mem, index);
    }
};
class llbool
{
    int mem = 0b0000'0000'0000'0000'0000'0000'0000'0000;
    public:
    llbool(const int& data)
        : mem(data) {}
    llbool() {}
    boolsProxy operator[] (const int& index)
    {
        return boolsProxy((long long*)&mem, index);
    }
};
class ulbool
{
    long long mem = 0b0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000'0000;
    public:
    ulbool(const long long& data)
        : mem(data) {}
    ulbool() {}
    boolsProxy operator[] (const int& index)
    {
        return boolsProxy((long long*)&mem, index);
    }
};
